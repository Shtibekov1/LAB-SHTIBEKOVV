# Лабораторная работа №4 — Асинхронность, промисы и крафт

Автор: Штибеков Муслим Тимурович 
Тема: Асинхронное программирование в JavaScript: таймеры, замыкания, промисы, последовательность выполнения кода и работа с интерфейсом.  
Цель: Закрепить понимание стека вызовов, event loop, таймеров, callbacks и объекта `Promise` на примере небольших задач и простой системы крафта предметов.

---



---

## Описание проделанной работы

В рамках лабораторной работы была создана страница `index.html` с тремя независимыми задачами:

1. **Resolve — промис, который резолвится через 2 секунды.**  
2. **Случайные данные и ошибки — функция `getData` с замыканием и вероятностным результатом.**  
3. **Крафт — асинхронная система изготовления предметов на промисах с логом и интерфейсом.**

Каждая задача расположена в отдельной секции с подзаголовком, имеет собственный интерфейс и работает без ошибок в консоли.

---

## 1. Задача «Resolve»

Создаётся функция `job`, которая возвращает промис, переходящий в состояние `fulfilled` через 2 секунды.  
В интерфейсе отображается статус выполнения, кнопка блокируется на время операции и разблокируется после.

---

## 2. Задача «Случайные данные и ошибки» (`getData`)

Функция `getData(probability, text)` создаёт замыкание и возвращает новую функцию, которая:

- принимает число,
- проверяет корректность аргумента,
- с заданной вероятностью возвращает либо новую строку `"Синтетические данные: ..."`, либо `null`.

Результат выводится в интерфейсе.

---

## 3. Задача «Крафт предметов»

Реализована система крафта:

- с зависимостями предметов,
- задержками времени изготовления,
- вероятностью провала,
- обновлением инвентаря,
- логом событий.

Используются структуры:

- `inventory` — хранилище количества ресурсов,
- `recipes` — описание предметов, времени крафта, зависимостей и вероятности провала.

Изготовление каждого предмета — это промис с задержкой и вероятностью ошибки.  
При создании предмета:

- проверяются зависимости через `ensureDependencies`,
- запускается крафт недостающих предметов,
- используется `Promise.all` для ожидания зависимостей,
- обновляется UI и лог событий.

---

# Вопросы для защиты (с ответами)

## 1. Стек вызовов (call stack)

Стек вызовов — это структура, где движок JS хранит информацию о текущих выполняемых функциях.  
Каждый вызов функции помещается в стек, завершение функции — удаляет её из стека.

---

## 2. Функции обратного вызова (callbacks)

Callback — это функция, переданная другой функции для вызова позже.  
Используется в событиях, таймерах, асинхронных операциях.

---

## 3. Таймеры в JS

- `setTimeout(callback, delay)` — однократный вызов, `clearTimeout(id)` — отмена.
- `setInterval(callback, delay)` — повторяющийся вызов, `clearInterval(id)` — отмена.

---

## 4. Замыкание

Замыкание — функция, которая помнит внешние переменные, даже когда выполняется вне их области видимости.  
Используется в задаче `getData` — внутренняя функция использует `probability` и `text`.

---

## 5. Асинхронное программирование в JS

Позволяет выполнять длительные операции без блокировки интерфейса.  
Использует callbacks, промисы, async/await, таймеры.

---

## 6. Event Loop

Механизм, который берёт задачи из очередей и запускает их, когда стек вызовов пуст.  
JS однопоточный, но event loop позволяет имитировать асинхронность.

---

## 7. Promise и его состояния

Промис имеет три состояния:

- `pending`
- `fulfilled`
- `rejected`

После перехода в конечное состояние промис становится неизменяемым.

---

## 8. Методы промиса

- `.then(onFulfilled)`
- `.catch(onRejected)`
- `.finally(onFinally)`
- `Promise.all()` — ожидание всех промисов.

Примеры находятся в задачах «Resolve» и «Крафт».

